\chapter{Herramienta Web. \emph{Front-End}}
\label{frontend}
Nuestra aplicación Web esta dividida en \emph{back-end} y \emph{front-end}. En el capítulo anterior se describió el \emph{back-end}. El propósito de
este capítulo es describir el \emph{front-end}, que es el encargado de la capa de presentación.
\par
El \emph{front-end} es implementado en JavaScript\cite{JavaScript}. Este es un lenguaje de programación soportado por la mayoría de navegadores Web,
nos permite dotar de funcionalidad extendida a nuestras páginas Web. Actualmente el uso de este lenguaje esta tan extendido y avanzado que permite
crear aplicaciones enteras para navegadores Web. Existen múltiples frameworks escritos en JavaScript que facilitan la creación de aplicaciones Web. En
este trabajo vamos a utilizar dos, Sencha ExtJs\cite{ExtJs} y HighStock\cite{HighStock}.
\par
Sencha ExtJs es un framework orientado a la creación de aplicaciones Web interactivas. Debido al gran abanico de funcionalidades que este framework
presenta, podemos decir que este es de propósito general. Este ofrece abstracciones para gestionar nuestros datos, arquitectura MVC, componentes
gráficos de control y otros.
\par
HighStock es un framework con un propósito específico. Este está orientado a facilitar la creación de gráficos. El framework es muy eficiente, esto
reduce la carga computacional de nuestra aplicación. Los gráficos generados por este son altamente interactivos, permiten ocultar series, navegar,
realizar zoom y mucho más.
\par
Empezaremos este capitulo aclarando los aspectos técnicos relacionados con estos dos frameworks. Explicaremos como usarlos, que funcionalidad nos
proporcionan, consideraciones que debemos tener en cuenta y mucho más.
\par
Como podemos ver en la figura \ref{frontend} nuestro \emph{front-end} esta basado en el patrón de diseño
\emph{modelo-vista-controlador}\cite{MVCWiki}. En la segunda parte de este capitulo hablaremos más a fondo sobre la división impuesta por este patrón
de diseño.
\begin{figure}[h]
	\centering
	\includegraphics[keepaspectratio, width=1\textwidth]{./img/frontend.png}
	\caption{\emph{Front-end}. Patrón MVC.}   
	\label{fig:frontend}
\end{figure}
\par
En nuestra aplicación también hacemos una división funcional, diferenciamos entre tres módulos funcionales que son \texttt{Spike},
\texttt{SpikeRevised} y \texttt{ChannelStats}. En las secciones finales de este capitulo hablaremos sobre estos módulos funcionales. 

\section{Sencha ExtJs}
	El propósito de esta sección es explicar alguno de los aspectos básicos del framework. Empezaremos explicando como crear una aplicación básica
	basándonos en ExtJs. En la mayoría de los casos existe un solo documento HTML\cite{HTML} que contiene toda la aplicación. En este documento
	tenemos que cargar dos \emph{scripts} de la siguiente forma.
    		\begin{center} \texttt{<script type="text/javascript" src=\textquotedbl extjs/ext-all-debug.js\textquotedbl ></script>}  \end{center}
    		\begin{center} \texttt{<script type="text/javascript" src=\textquotedbl app.js\textquotedbl ></script>}  \end{center}
 	El primer \emph{script} contiene el framework que queremos utilizar. Es conveniente destacar que esta es una versión concebida para el proceso
	de desarrollo. Para la versión final es conveniente usar el \texttt{ext-all.js}.
 	\par
 	El segundo \emph{script} es el que contiene la lógica de nuestra aplicación. A continuación podemos ver el código mínimo para crear una
	aplicación. El código presentado será explicado a fondo.
	\begin{lstlisting}
Ext.application({
   name: 'HelloExt',
   launch: function() {
      Ext.create('Ext.container.Viewport', {
         layout: 'fit',
            items: [{
               title: 'Hello Ext',
               html : 'Hello! Welcome to Ext JS.'}] 
      }); 
   } 
});
	\end{lstlisting}
 	En la primera línea hacemos uso del singletone \texttt{Ext}. Este es un objeto que encapsula todas las clases, métodos y singletones
	proporcionados por el framework. La función utilizada \texttt{Ext.application} carga e inicializa una instancia de la clase
	\texttt{Ext.app.Application}. Esta clase representa una aplicación ExtJs single page. La llamada a esta función crea la variable global
	\texttt{MyApp}, que debe contener todas las clases e instancias de nuestra aplicación.
 	\par
 	En la segunda línea declaramos el nombre de nuestra aplicación. Seguidamente definimos la función \texttt{launch}. Esta es la función que debe
	lanzar  nuestra aplicación. La primera función invocada es \texttt{Ext.create} que crea una instancia de la clase proporcionada, en este caso
	\texttt{Ext.container.Viewport}. \texttt{Viewport} es un \emph{contenedor} que representa el área de aplicación y puede haber tan solo uno por
	aplicación. 
 	\par
 	La interfaz de usuario en una aplicación ExtJs es compuesta por \emph{componentes}. Un \emph{contenedor} es un \emph{componente} especial que
	contiene otros \emph{componentes}. En la figura \ref{fig:comps} podemos ver un ejemplo que ilustra esta jerarquía.
	\begin{figure}[h]
		\centering
		\includegraphics[keepaspectratio, width=1\textwidth]{./img/comps.png}
		\caption{Sencha ExtJs. Jerarquía de componentes.}   
		\label{fig:comps}
	\end{figure}
 	\par
 	El \texttt{Viewport} es el \emph{contenedor} que contiene todos los demás \emph{componentes} de nuestra aplicación. Los \emph{compenentes} de
	un \emph{contenedor} se especifican en el campo \texttt{items} que es una lista. En el ejemplo presentado tan solo tenemos un 
	\emph{conponente}, pero pueden ser añadidos más.
 	\par
 	Fijándonos en el código de ejemplo podemos ver que antes de definir el campo \texttt{items} definimos el campo \texttt{layout}. El \texttt{layout}
	especifica la forma en la que se posicionan y ajustan los \emph{componetes} hijos dentro del padre. En este caso el \texttt{layout} especificado es 
	\texttt{\cc fit\cc}, donde un solo hijo ocupa todo el espacio del padre.
\section{Sencha ExtJs Component Manager}
	ExtJs ofrece el singletone \texttt{Ext.ComponentManager} que provee un registro con todos los componentes. Esto facilita la referencia a
	elementos desde cualquier punto del código. El propósito de esta sección es explicar como hacer uso de esta facilidad.
	\par
	Empezaremos especificando un requisito que  los componentes deben cumplir, estos deben definir el atributo \texttt{itemId}. Este atributo es
	el identificador del componente. El ámbito que tiene este identificador es local al contenedor que contiene el componente. Esto hace que los
	identificadores no tengan que ser únicos. 
	\par
	Es el singletone \texttt{Ext.ComponentQuery} el que nos permite realizar búsquedas de componentes en función del \texttt{itemId}. Concretamente
	es \texttt{Ext.ComponentQuery.query()} el método que nos permite realizar las búsquedas. Este método acepta dos parámetros. El primer
	parámetro, \texttt{selector}, es un String y especifica el \texttt{itemId} que queremos buscar. El segundo parámetro, \texttt{root} es
	opcional y especifica el contenedor dentro de cual queremos hacer la búsqueda. Si el segundo parámetro es omitido la búsqueda se realizara
	entre todos los componentes. La función devuelve un array con todos los componentes que reúnen las condiciones, pudiendo ser este un array
	vacío. Eventualmente podemos hacer búsquedas más complejas, podemos buscar por tipo, atributos y mucho más. En este trabajo tan solo hemos
	utilizado queries simples, razón por la que no explicamos como se realizan estas queries avanzadas.
	\par
	La clase \texttt{Ext.container.Container} implementa las funciones \texttt{down()} y \texttt{query()}. Estas dos realizar una llamada a
	\texttt{Ext.ComponentQuery.query()} teniéndose a si mismo como parámetro \texttt{root}. Esto les permite hacer una búsqueda entre sus hijos.
	\par
	También existe el método \texttt{up()} implementado por \texttt{Ext.Component}. Este permite hacer una búsqueda similar a las anteriormente
	descritas. En este caso se navega hacia arriba en la jerarquía de componentes y se busca por componentes que reúnen los criterios. Esta
	función puede ser invocada sin ningún parámetro, caso en el que devuelve el padre inmediato del componente.
	\par
	Es conveniente citar el parámetro \texttt{id} y la función \texttt{Ext.getCmp()}. Estos dos ofrecen una funcionalidad parecida a la
	anteriormente explicada, pero no deben ser usados con ese propósito. Estan considerados como obsoletos y pueden dar lugar a colisiones. 

\section{Sencha ExtJs Layouts}
	El propósito de esta sección es explicar los layouts utilizados en este trabajo. Tan solo explicaremos la funcionalidad de estos sin
	centrarnos en el uso que les hemos dado, este será explicado en las secciones venideras cuando proceda. En la figura \ref{fig:layouts} podemos
	ver una representación de los layouts que describiremos a continuación.
	\subsection{\texttt{Absolute}}
		Los \emph{componentes} hijo son posicionados mediante el uso de coordenadas \texttt{X,Y}. Las dimensiones de estos también se definen
		de forma estática mediante el uso de dos atributos, \texttt{height} and \texttt{width}. La posición y tamaño de los componentes se
		puede cambiar mediante el uso de las funciones \texttt{setPosition()} y \texttt{setSize()}.
	\subsection{\texttt{Accordion}}
		Este layout se asemeja a un acordeón. Los \emph{componentes} hijo pueden ser expandidos y colapsados, teniendo tan solo uno expandido
		a la vez. Los \emph{componentes} son ordenados en vertical ocupando todo el espacio disponible. Las funciones \texttt{expand} y
		\texttt{collapse} nos permiten expandir y colapsar los paneles hijo. También están presentes multitud de manejadores de eventos que
		podemos sobrescribir, en nuestro caso haremos uso del \texttt{beforeExpand} que se dispara antes de expandir un \emph{componente}. 
	\subsection{\texttt{Border}}
		Este layout nos permite tener hasta cinco \emph{componentes} dispuestos de la manera que podemos ver en la figura \ref{fig:layouts}.
		Los componentes hijos deben especificar al atributo \texttt{region} que determina el posicionamiento de estos. El atributo puede tomar
		los siguientes valores \texttt{[north, east, south, west, center]}. No es necesario que estén presentes los cinco hijos, podemos
		omitir los no deseados. Esto hace que este layout sea muy flexible e interesante.
	\subsection{\texttt{Card}}
		Este layout maneja multiples \emph{componentes} hijo. Los hijos ocupan todo el espacio disponible, por lo que se solapan uno a otro.
		Esto hace que solo uno pueda ser visible a la vez. El layout asemeja una baraja de cartas donde solo una carta puede estar en la parte
		superior. La función que nos permite hacer visible un hijo es \texttt{setActiveItem()}. Esta función acepta el \emph{componente}, el
		\texttt{itemId} del \emph{componente} o el índice del \emph{componente}.
	\subsection{\texttt{Fit}}
		\texttt{Fit} es un layout muy simple, este tan solo acepta un hijo que ocupa todo el espacio que el padre ofrece. El \emph{componente}
		hijo se expandirá automáticamente para ajustarse al tamaño del padre.
	\subsection{\texttt{HBox y VBox}}
		Estos son dos layouts diferentes, pero muy parecidos, razón por la que serán explicados en la misma subsección. El \texttt{HBox}
		organiza sus elementos hijos de forma horizontal a lo largo del \emph{componente} padre. El \texttt{VBox} hace lo mismo, pero la
		organización es de forma vertical. Los componentes hijos pueden especificar el atributo \texttt{flex}, este atributo determina como
		será repartido el espacio disponible entre los diferentes hijos. Para ilustrar el funcionamiento del \texttt{flex} expondremos un
		ejemplo. Teniendo dos \emph{componentes} hijo con \texttt{1} y \texttt{2} de \texttt{flex} respectivamente, el primero ocupara 1/3 y el
		segundo 2/3 del espacio total.
	\begin{figure}[h]
		\centering
		\includegraphics[keepaspectratio, width=1\textwidth]{./img/layouts.png}
		\caption{Sencha ExtJs. Layouts.}   
		\label{fig:layouts}
	\end{figure}

\section{Sencha ExtJs Lazy instantiation}
	La inicialización perezosa es una técnica que consiste en retrasar la creación de recursos hasta el momento en el que sean necesarios. Como
	hemos visto en la sección dedicada a los layouts en muchos casos los componentes no son visibles. Tener que crear todos los componentes al
	inicializar la aplicación no es muy eficiente, dado que tan solo unos pocos son visibles. Crear tan solo los componentes visibles y después ir
	creando los componentes según se vayan necesitando supone un incremento en el rendimiento. En páginas pequeñas con pocos componentes el
	aumento no es apreciable, sin embargo en páginas que manejan multitud de componentes el incremento puede ser drástico. 
	\par
	Para implementar esta inicialización perezosa ExtJs se basa en la jerarquía de componentes previamente explicada. Cuando un componente es
	creado también se crean todos los componentes hijos que deben ser visibles en ese momento. Tal y como explicamos los componentes hijos se
	definen en el campo \texttt{items}. A continuación podemos ver un pequeño ejemplo. 
	\begin{lstlisting}
items:[
   Ext.create('Ext.form.field.Text',{
      fieldLabel:'Foo'}),
   Ext.create('Ext.form.field.Text', {
      fieldLabel: 'Bar'})]
	\end{lstlisting}
	El ejemplo presentado anteriormente no habilita la inicialización perezosa. Para este propósito tenemos que evitar el uso de la función
	\texttt{Ext.create()}. Tenemos que especificar los componentes hijos como objetos de configuración. A continuación se presenta un ejemplo.
	\begin{lstlisting}
items: [{
   xtype: 'textfield',
   fieldLabel: 'Foo'},
{
   xtype: 'textfield',
   fieldLabel: 'Bar'}]
	\end{lstlisting}
	La diferencia que podemos apreciar entre los dos ejemplos es el atributo \texttt{xtype}. Este especifica la clase que tendrá el componente.
	Como podemos ver no se especifica el nombre completo de la clase. \texttt{xtype} acepta una serie de atajos para referenciar a las clases. En
	nuestro caso la clase \texttt{Ext.form.field.Text} es referenciada por el \texttt{xtype:\cc textfield\cc}.
	\par
	La lista completa de \texttt{xtypes} aceptados podemos ver en la documentación de ExtJs\cite{ExtJsDoc}. Eventualmente podemos extender esta
	lista declarando nuestros propios \texttt{xtypes}. Esto se hace especificando el campo \texttt{xtype} a la hora de definir nuestra clase. A
	continuación presentamos un pequeño ejemplo.
	\begin{lstlisting}
Ext.define('MyApp.PressMeButton', {
   extend: 'Ext.button.Button',
   xtype: 'pressmebutton',
   text: 'Press Me'});
	\end{lstlisting}

\section{Sencha ExtJs Events}
	Las clases y componentes de ExtJs disparan multitud de eventos a lo largo de su ciclo de vida. Los eventos se disparan cuando algo interesante
	le ocurre a nuestro componente. Un ejemplo es el evento \texttt{afterrender} que se dispara después de mostrar en pantalla el componente.
	\par
	La parte interesante de los eventos es que podemos definir funciones, \texttt{listeners}, que se ejecuten cuando se produzca un evento
	determinado. De esta manera somos capaces de responder a dichos eventos. A continuación presentamos un ejemplo en el que podemos ver como
	manejar dichos eventos. En el ejemplo trataremos el evento \texttt{click}, evento que se dispara al hacer \emph{click} sobre un componente. 
	\begin{lstlisting}
Ext.create('Ext.Button',{
   text: 'Click Me',
   renderTo: Ext.getBody(),
   listeners:{
      click: function(){
         Ext.Msg.alert('I was clicked!');}
   }
});
	\end{lstlisting}
	\par
	ExtJs también nos permite configurar eventos propios. Estos eventos se declaran como si fuesen eventos normales. La peculiaridad esta en que
	somos nosotros los que tenemos que disparar esos eventos. Para disparar un evento tenemos que hacer uso de la función \texttt{fireEvent} que
	acepta como parámetros el evento que queremos disparar y todos los parámetros que la función encargada del evento necesite. A continuación
	podemos ver un pequeño ejemplo de como declarar y disparar un evento propio, que tiene como nombre \texttt{myEvent}.
	\begin{lstlisting}
var button = Ext.create('Ext.Button',{
   text: 'Custom Event',
   renderTo: Ext.getBody(),
   listeners:{
      myEvent: function(number){
         Ext.Msg.alert('Custom event fired, number: '+number);}
   }
});

button.fireEvent('myEvent', 42);
	\end{lstlisting}

%Muy mal. %Si sobra contenido esta sección tiene que ser eliminada.
\section{Sencha ExtJs Components}
	ExtJs ofrece multitud de componentes, todos son subclases del \texttt{Ext.Component}, cada uno con un propósito diferente. El objetivo de esta
	sección es describir los componentes usados en este trabajo. Nos centraremos en los aspectos técnicos sin especificar el uso concreto que les
	hemos dado, este será explicado en secciones futuras cuando proceda. 
	\subsection{\texttt{Ext.button.Button xtype:button}}
		Este componente nos permite crear un botón. El propósito de un botón es ofrecer un medio fácil al usuario para interactuar con la
		aplicación. Los botones que ExtJs ofrece son altamente configurables, tanto funcionalmente como estéticamente. Podemos tener botones
		normales, botones \emph{toggle}, botones que despliegan menús y mucho más. Para dar funcionalidad a estos botones tenemos que escuchar
		por los eventos que estos disparan. Los eventos más comunes son \texttt{click}, \texttt{toggle}, \texttt{mouseover} y \texttt{mouseout}.
	\subsection{\texttt{Ext.form.field.Date xtype:datefield}}
		Este componente proporciona un campo de entrada de fecha. Es posible especificar el formato deseado en el que introducir la fecha. Si
		este formato no es respetado el campo es subrayado en color rojo indicando al usuario la inconsistencia. Eventualmente este campo
		puede desplegar un selector de fechas que facilita el proceso de introducir la fecha deseada. Al igual que los demás componentes este
		dispara multitud de eventos que podemos manejar.
	\subsection{\texttt{Ext.form.field.Time xtype:timefield}}
		Este componente es muy similar al anteriormente descrito. Este proporciona un campo de entrada de tiempo. También acepta una
		configuración del formato deseado y advierte  al usuario cuando este no es respetado. El componente puede desplegar un selector de
		tiempo que facilita la tarea de introducir el valor deseado.
	\subsection{\texttt{Ext.form.Label xtype:label}}
		Este componente nos permite generar una etiqueta de texto. Este componente es muy similar al tag HTML <label>. Este componente nos
		permite configurar múltiples aspectos y manejar múltiples eventos.
	\subsection{\texttt{Ext.panel.Panel xtype:panel}}
		Este componente es una parte fundamental en la creación de aplicaciones con ExtJs. Esta pensado para ser utilizado como un contenedor,
		contener otros componentes. Este componente es altamente configurable pero el aspecto más importante es el \texttt{layout} que
		determina como se posicionan los componentes hijos. 
	\subsection{\texttt{Ext.tab.Panel xtype:tabpanel}}
		Este componente es una extensión del componente anterior. Este ofrece múltiples pestañas en la que organizar los componentes hijos.
		Esto permite incluir una cantidad mayor de contenido en el mismo espacio. La barra de pestañas que el componente ofrece es altamente
		configurable. 
	\subsection{\texttt{Ext.grid.Panel xtype:gridpanel}}
		Este componente es un contenedor capaz de presentar una tabla. Las tablas son altamente interactivas, estas permiten al usuario
		ordenar los datos, hacer búsquedas, eliminar datos, añadir datos y mucho más.

\section{Sencha ExtJs History stack}
	La aplicación Web que estamos desarrollando es una aplicación \emph{single page}. Este modelo rompe con el patrón tradicional de navegación
	por el historial usando los botones \emph{Forward/Back}. Esto presenta un problema de usabilidad cuando el usuario utiliza el botón de
	navegación hacia atrás, este espera volver al estado anterior de la aplicación, sin embargo sera cargada la página anterior del historial y
	nuestra aplicación \emph{single page} será descargada.
	\par
	La solución que la mayoría de aplicaciones \emph{single page} han adoptado se basa en el \emph{Fragment Identifier}  o \emph{hash}, nombre que
	recibe porque va precedido del símbolo \textbf{\#}. El \emph{hash} es una parte opcional de la URL que históricamente se utilizaba para navegar
	por documentos largos, un cambio en el \emph{hash} hace que se muestres diferentes partes del documento.
	\par
	Actualmente el \emph{hash} es usado por aplicaciones \emph{single page} para manipular la pila de historial. El hash es cambiado acuerdo al
	estado de la aplicación. Esto hace que los cambios en la aplicación sean registrados en la pila de historial.
	\par
	Al pulsar el botón de navegación hacia atrás el \emph{hash} de la URL cambia a su estado anterior. Nuestra aplicación debe ser capaz de
	detectar los cambios en el \emph{hash} y actuar acuerdo a estos. De esta manera podemos preservar la funcionalidad de los botones de
	navegación \emph{Forward/Back}. 
	\par
	Para implementar la funcionalidad anteriormente descrita ExtJs nos ofrece el singletone \texttt{Ext.util.History}. Para inicializar este módulo
	tenemos que invocar la función \texttt{Ext.History.init()}. Una vez inicializado este módulo podemos hacer cambios en el \emph{hash} invocando
	la función \texttt{Ext.History.add()}. Esta función acepta como parámetro el valor del \emph{hash}. 
	\par
	Para detectar y actual acorde a los cambios del \emph{hash} tenemos que inicializar un \texttt{listener}. El evento que vamos a capturar es
	\texttt{change}. A continuación podemos ver un pequeño código de como inicializar el \texttt{listener}.
	\begin{lstlisting}
Ext.History.on('change', function(hash){
   switch(hash){
      case: 'Foo':
         //Actuar acuerdo al hash Foo
         break;
      case: 'Bar'
         //Actuar acuerdo al hash Bar
         break;
   };
});
	\end{lstlisting}
	\par
	El propósito de esta sección ha sido explicar el problema que surge con el historial de navegación y como prevenir lo haciendo uso del
	\texttt{Ext.History}. Del uso concreto que hemos hecho de este módulo hablaremos en secciones futuras de este capítulo.


\section{HighStock}
	El propósito de esta sección es explicar alguno de los aspectos básicos del Framework. Actualmente existen dos frameworks desarrollados por la
	misma organización, HighCharts y HighStock. Los dos framework son muy parecidos y es conveniente explicar las diferencias que existen entre
	estos. El primero tiene un propósito más general, la variedad de gráficos que permite crear es mucho más extensa. El segundo tiene un
	propósito más general, este está enfocado a la representación gráfica de valores que evolucionan respecto al tiempo. Este enfoque es muy
	adecuado para nuestro caso. A continuación presentaremos el código mínimo necesario para crear un gráfico con HighStock. Basándose en ese
	código explicaremos los aspectos técnicos del software.
	\begin{lstlisting}
myChart = new Highcharts.StockChart({
   chart: {
      renderTo: container}, //HTML element reference
   series: [{
      name: 'My First Series',
      data: myData // predefined JavaScript array
   }]
});
	\end{lstlisting}
	Como podemos ver para crear un gráfico invocamos la función \texttt{HighCharts.StockChart()}. Esta función acepta como parámetro un objeto que
	define la configuración del gráfico. El formato de este objeto puede verse en la documentación del framework\cite{HighStockDoc}. En nuestro
	caso tan solo especificaremos dos atributos, la mayoría de los atributos tiene un valor por defecto por lo que no es necesario especificarlos
	explícitamente. 
	\par
	El primer atributo que especificamos es \texttt{chart}. Este atributo es un objeto que a su vez especifica  aspectos básicos del gráfico. El
	atributo que especificamos es \texttt{renderTo}, el elemento HTLM en el que nuestro gráfico será presentado.
	\par
	El segundo atributo que especificamos es \texttt{series}. Este es un array de objetos que especifican las series de nuestro gráfico. En este
	ejemplo tenemos tan solo un objeto, por lo que nuestro gráfico tendrá tan solo una serie.  Definiendo el atributo \texttt{name} le damos un
	nombre a nuestra serie y especificando el atributo \texttt{data} le damos datos a nuestra serie. El atributo \texttt{data} tiene que ser un
	array que contenga los datos, este array puede tener múltiples formatos que no explicaremos dado que están muy bien explicado en la
	documentación proporcionada\cite{HighStockDoc}.
	\par
	En este punto volveremos al \texttt{renderTo} a fin de explicar la integración entre HighStock y Sencha ExtJs. En secciones anteriores
	explicamos que la interfaz de usuario de una aplicación ExtJs se constituye de componentes. Estos componentes son abstracciones con
	funcionalidades muy extendidas pero en el fondo son un elemento HTML. Este elemento será asignado al atributo \texttt{renderTo} a fin de
	mostrar un gráfico HighStock en un componente de una Aplicación ExtJs. El elemento HTML de un componente es accesible de la siguiente forma.
    		\begin{center} \texttt{Ext.Component.detEl().dom}  \end{center}

\section{HighStock Agrupación de datos y \emph{Candlestick}} 
	\begin{wrapfigure}{R}{0.42\textwidth}
		\centering
	        \includegraphics[keepaspectratio, width=0.40\textwidth]{./img/candlestick.png}
		\caption{Gráfico Candlestick.}
		\label{fig:candlestick}
	\end{wrapfigure}
	El objetivo de esta sección es explicar el gráfico \emph{Candlestick} o gráfico de velas. Hemos utilizado este gráfico para dar solución a un
	problema que explicaremos a continuación. Seguidamente explicaremos como interpretar este gráfico.
	\par
	El problema radica en la gran cantidad de datos que tienen que ser representados en nuestro gráfico. El sistema de adquisición genera una
	entrada de datos cada minuto, 1440 datos al día o 43200 datos al mes. Estas cantidades de datos son excesivas comparadas con las resoluciones
	de pantalla actuales. Consideremos una pantalla estándar con 1280 pixeles de ancho, es imposible representar 43200 datos.
	\par
	Para dar solución a este problema hemos recurrido a agrupar los datos. El fin es crear un número de grupos que no exceda el ancho de pixeles
	de nuestra pantalla. Para cada grupo tenemos que calcular un valor representativo. Una técnica común es calcular el valor medio de los grupos.
	Esto tiene el inconveniente de aplanar los Spikes, algo que queremos resaltar.
	\par
	Para evitar aplanar los Spike para cada grupo calcularemos valores más representativos que la media. En concreto calcularemos cuatro valores,
	máximo, mínimo, \emph{open} y \emph{close}. El \emph{open} y \emph{close} son la media más la desviación típica y la media menos la desviación
	típica respectivamente.
	\par
	El agrupamiento de datos y cálculo de estos cuatro valores por cada grupo esta implementado en el \emph{back-end}. Los servicios RPC que nos
	permiten acceder a estos datos son \texttt{nmdbOriginalGroup} y \texttt{nmdbRevisedGroup}. Estos servicios fueron explicados en el capítulo
	dedicado al \emph{back-end}, en este punto tan solo nos interesa destacar el argumento \texttt{points} que estos dos servicios aceptan. Este
	argumento especifica el número de grupos en los que serán agrupados los datos, este será proporcional al número de pixeles que tenemos
	disponibles para representar nuestro gráfico. 
	\par
	Con los valores máximo, mínimo, \emph{open} y \emph{close} de cada grupo crearemos un gráfico Candlestick. Este es un gráfico usado en
	análisis técnico bursátil donde tiene su significado propio. En este trabajo tiene su significado propio que podemos ver en la figura
	\ref{fig:candlestick}. Como podemos ver el \emph{open} y \emph{close} son utilizados para construir el cuerpo de las velas. El cuerpo de las
	velas representa los datos que se encuentran dentro de la desviación típica. La línea que cruza el cuerpo de la vela representa el valor
	máximo y mínimo para cada grupo.
	\par
	Las velas con cuerpos alargados indican grupos en los que la desviación típica es muy grande, por contrario velas con cuerpos contraídos
	indican grupos con una desviación típica pequeña. Los dos extremos, datos que fluctúan mucho o datos que no fluctúan, pueden ser indicativo de
	un mal funcionamiento. Los valores máximo o mínimo que se alejan mucho del cuerpo de la vela nos indican la presencia de un Spike en dicho
	grupo. 

\section{Ampliando HighStock}
	HighStock es construido de forma modular para facilitar la ampliación por parte de los usuarios. En este trabajo hemos ampliado el framework
	con dos funcionalidades adicionales. El propósito de esta sección es describir estas dos funcionalidades, pero primero explicaremos el proceso
	para ampliar el framework.
	\par
	La primera consideración que tenemos que tener es el ámbito o \emph{scope}, nombre que utilizaremos a lo largo de este trabajo. Debemos tener
	cuidado de no contaminar el \emph{scope} global con variables. Para este propósito debemos utilizar una función \emph{self-invoking}. En
	JavaScript esta es una función que se ejecuta inmediatamente y crear su propio \emph{scope}, de esta manera evitamos contaminar el
	\emph{scope} global. A continuación presentamos un ejemplo de como declarar una de estas funciones.
	\begin{lstlisting}
(function (H) {
   var localVar,	// Variable local
   Series = H.Series;
   doSomething();
}(Highcharts));
	\end{lstlisting}
	\par
	El framework nos ofrece la función \texttt{wrap} que nos permite añadir código en una función existente. Podemos añadir dicho código antes o
	después del código inicial de la función. La función acepta tres argumentos, el objeto padre como primer argumento, el nombre de la función
	como segundo argumento y la función de sustitución como tercer argumento. La función original es pasada como el primer argumento de la función
	de sustitución. Es conveniente fijarnos en el ejemplo de código a continuación presentado para entender mejor el uso de la función
	\texttt{wrap}.
	\begin{lstlisting}
H.wrap(H.Series.prototype, 'drawGraph', function (proceed) {
// Antes de la funcion original.
console.log("We are about to draw the graph: ", this.graph);
// Invocar la funcion original usando todos los argumentos menos el primero.
proceed.apply(this, Array.prototype.slice.call(arguments, 1));
// Despues de la funcion original.
console.log("We just finished drawing the graph: ", this.graph);
});
	\end{lstlisting}
	\par  
	A continuación explicaremos las dos ampliaciones que hemos realizado sobre el framework, la primera nos permite realizar zoom Out y la segunda
	nos permite resaltar las series de un gráfico para poder inspeccionarlas mejor.
	\subsection{Ampliación. Zoom Out}
		Tal y como explicamos los gráficos creados con el framework son altamente interactivos. Entre las diferentes funcionalidades están las
		que nos permiten navegar por el conjunto de datos. Con navegar nos referimos a mostrar diferentes fragmentos de los datos. Un ejemplo
		de estas funcionalidades es el zoom In, que nos permite ampliar una sección de datos. Haciendo \emph{click} y arrastrando podemos
		seleccionar un intervalo para realizar el zoom In. Poder hacer zoom In es muy útil para inspeccionar los datos, el problema es que el
		framework no nos ofrece la posibilidad de realizar un zoom Out.
		\par
		En este trabajo hemos extendido el framework para incorporar dicha funcionalidad. Para este propósito modificaremos el zoom In,
		usaremos la dirección de arrastre para diferenciar entre zoom In y zoom Out. Un arrastre de izquierda a derecha realizar un zoom In,
		mientras que un arrastre de derecha a izquierda realizar un zoom Out. 
		\par
		Para poder registrar la dirección de arrastre hemos hecho uso de dos eventos, \texttt{mousedown} y \texttt{mouseup}. En cada evento
		registramos la posición de este y usamos la diferencia entre las posiciones para determinar la dirección de arrastre. A continuación
		presentamos el código. Es la variable \emph{selectDirection} la que nos indica la dirección de arrastre.
		\begin{lstlisting}
H.addEvent(container, 'mousedown', function (e) {
   selectFrom = chart.pointer.normalize(e).chartX;
});

H.addEvent(container, 'mouseup', function (e) {
   selectTo = chart.pointer.normalize(e).chartX;
   selectDirection = selectTo - selectFrom;													            
});
		\end{lstlisting}
		\par
		El evento que se dispara al realizar una selección en \texttt{selection}, por lo que tenemos que registrar un manejador para el
		evento. La primera acción es comprobar el estado del \emph{selectDirection}, la variable que nos indica la dirección de arrastre. En
		el caso de que la variable tenga un valor positivo no tomamos acción, dejamos que se realice el zoom In por defecto. Si por contrario
		la variable tiene un valor negativo tenemos que realizar un zoom Out. La primera acción que tomamos es prevenir la acción por defecto.
		Seguidamente calculamos los valores que definen el nuevo intervalo temporal y para terminar aplicamos el nuevo intervalo al gráfico. A
		continuación se puede ver el código que implementa la funcionalidad previamente descrita.
		\begin{lstlisting}
H.addEvent(chart, 'selection', function (e) {
   if (selectDirection < 0) {
      e.preventDefault();
      //Calcular newMin y newMax
      xAxis.setExtremes(newMin, newMax);
   }
});
		\end{lstlisting}

	\subsection{Ampliación. Resaltar series}
		En la mayoría de casos las estaciones de neutrones de monitores se componen por 18 tubos contadores. Los gráficos que representan la
		información de los tubos por separado se vuelven un poco confusos debido al gran número de series. Este problema crea la necesidad de
		tener un mecanismo que permita resaltar una serie del gráfico para poder inspeccionarla mejor. Para crear dicho mecanismo utilizaremos
		la leyenda del gráfico.
		\par
		HighStock permite añadir una leyenda a los gráficos, elemento gráfico que facilita el identificar e interpretar las diferentes series
		del gráfico. La leyenda al igual que los gráficos es altamente interactiva. Haciendo \emph{click} sobre los elementos de una leyenda
		podemos mostrar u ocultar la serie correspondiente. En este trabajo preservaremos esta funcionalidad y añadiremos la funcionalidad de
		resaltar una serie. Para este propósito utilizaremos los eventos \texttt{mouseover} y \texttt{mouseout}, la serie será resaltada al
		posicionar el puntero sobre el elemento correspondiente de la leyenda. 
		\par
		El proceso de resaltar una serie para poder visualizarla mejor consiste en bajar la opacidad de todas las demás series, de esta manera
		la serie que queremos resaltar es más visible. En la figura \ref{fig:resalto} podemos ver el resultado que obtenemos. A la izquierda
		podemos ver el gráfico antes de resaltar una serie, vemos que las mediciones de los 18 canales se solapan y es difícil examinarlas. A
		la derecha podemos ver el canal 13, \emph{ch13}, resaltado. Vemos como este mecanismo facilita el proceso de inspeccionar los datos.
		\begin{figure}[h]
			\centering
			\includegraphics[keepaspectratio, width=1\textwidth]{./img/resalto.png}
			\caption{Ampliando HighStock. Resaltar series.}   
			\label{fig:resalto}
		\end{figure}

\section{\emph{Modelo}}
	El \emph{modelo} es el encargado de manejar los datos de una aplicación. En el caso del \emph{front-end} los datos de la aplicación deben ser
	servidos por el \emph{back-end}. El \emph{modelo} es el encargado de realizar la comunicación con el \emph{back-end}. 
	\par
	Tal y como especificamos en el  capítulo anterior el protocolo para la comunicación entre los dos módulos es \emph{HTTP}. Nuestro
	\emph{front-end} es el que empieza la comunicación enviando un mensaje de petición y el \emph{back-end} responde a esa peticion con un mensaje
	de respuesta. El \emph{modelo} es el encargado de construir y enviar los mensajes de petición y después interpretar los mensajes de respuesta.
	\par
	Para dotar el \emph{modelo} de la funcionalidad necesaria vamos a ayudarnos de las facilidades que nos ofrece ExtJs, concretamente vamos a
	utilizar el singletone \texttt{Ext.Ajax}. Ajax\cite{AjaxWiki} es una técnica de desarrollo Web donde cliente y servidor mantienen una
	comunicación asíncrona en segundo plano. \texttt{Ext.Ajax} es un singletone de la clase \texttt{Ext.data.Connection}, clase que encapsula la
	lógica necesaria para realizar una comunicación Ajax. 
	\par
	Concretamente vamos a hacer uso de la función \texttt{Ext.data.Connection.request}. Esta función envía una petición \emph{HTTP} a un servidor
	remoto. La función acepta un solo parámetro que es un objeto cuyas propiedades definen el comportamiento de la función. Las propiedades de las
	que nosotros haremos uso están detalladas a continuación. 
	\begin{itemize}
  		\item	\texttt{url}. 	La URL a la que enviaremos la petición. En nuestro caso \emph{back-end} y \emph{front-end} estarán albergados en
		  	el mismo \emph{host}. Esto nos permite no especificar el \emph{host}, la petición se hará al \emph{host} utilizado para cargar
			la aplicación. En la URL tan solo tendremos que especificar el servicio deseado y los parámetros que acompañan a este.
			Seguidamente presentamos un ejemplo del valor que puede tomar el campo \texttt{url}.
    				\begin{center} \texttt{url: \cc/nmdadb/cannel/stats/default/default\cc}  \end{center}
		\item	\texttt{method}. El método que especifica nuestro mensaje de petición. Los mensajes \emph{HTTP} de petición pueden especificar
		  	un método. Si este campo es dejado vacío el método utilizado será \texttt{GET}. La mayoría de los servicios ofrecidos por el
			\emph{back-end} aceptan un método \texttt{GET}, pero el servicio \texttt{nmdbMarkNull} acepta un método \texttt{POST}.
		\item	\texttt{success}. La función a ser llamada al completar exitosamente la petición. Esta función a su vez acepta como parámetro
		  	\texttt{response}. Este parámetro contiene los datos del mensaje de respuesta.
		\item	\texttt{failure}. La función a ser llamada al completar sin éxito la petición. Esta función también acepta el parámetro
		  	\texttt{response} que podemos utilizar para identificar la causa del fallo.
		\item	\texttt{timeout}. El numero de milisegundos en los que el \emph{back-end} debe responder. Si el tiempo expira la solicitud se
		  	considera como fallida. 
	\end{itemize}
	Más allá de \emph{Ext.data.Connection} el framework ofrece abstracciones de un nivel superior. La clase \emph{Ext.data.Model} es una
	representación de un objeto utilizado por nuestra aplicación. Estos modelos son usados por la clase \emph{Ext.data.Store}, que encapsula
	instancias de un modelo. La clase \emph{Ext.data.Store} también hace uso del \emph{Ext.data.proxy.Proxy}, abstracción que permite cargar y
	guardad datos de un modelo. 
	\par
	Estas abstracciones son muy útiles, pero algo complejas. Al no estar acostumbrado a trabajar con ellas el autor de este trabajo ha preferido
	utilizarlas lo menos posible. Por esta razón la mayoría de los datos se manejan usando el \texttt{Ext.data.Connection}, hemos utilizado el
	\texttt{Ext.data.Store} en casos muy específicos.
	%TODO Explicar Modelo, Store y Proxy.
\section{\emph{Controlador}}
	El Controlador en una aplicación \emph{modelo-vista-controlador}\cite{MVCWiki} es el que responde a eventos, normalmente estos eventos son
	peticiones del usuario. Las respuestas consisten en peticiones al Modelo para cargar datos o bien en comandos dirigidos a la Vista para
	realizar un cambio en la forma de mostrar los datos. Podemos decir que este modulo es el encargado de intermediar entre la Vista y el Modelo.
	El propósito de esta sección es explicar este módulo en profundidad.
	\par
	Sencha ExtJs nos ofrece la clase \texttt{Ext.app.Controller}, abstracción que representa un Controlador. Esta clase contiene la funcionalidad
	mínima necesaria, esta pensada para ser extendida y dotada de funcionalidad por el usuario. A continuación podemos ver un pequeño ejemplo de
	como declarar un Controlador básico en Sencha ExtJs.
	\begin{lstlisting}
Ext.define('MyApp.controller.Users', {
   extend: 'Ext.app.Controller',
   onLaunch: function() {
      console.log('Podemos empezar..');}
});
	\end{lstlisting}
	La función \texttt{onLaunch} es una función especial que es invocada después de inicializar la aplicación. La Vista y Modelo ya están
	inicializados, por lo que es un buen punto para empezar a actuar sobre estos elementos.
	\par
	Antes de empezar a discutir los Controladores que hemos implementado en este trabajo es conveniente destacar que el framework ofrece una
	facilidad similar al \texttt{Ext.ComponentQuery}, pero para los Controladores. Podemos hacer queries para acceder a los Controladores desde
	cualquier punto del código. A continuación podemos ver como hacer uso de esta facilidad.
    		\begin{center} \texttt{MyApp.app.getController("Nombre\_del\_Controlador")}  \end{center}
	\par
	En nuestra aplicación hemos definido cinco Controladores. En las subsecciones venideras discutiremos estos cinco Controladores que hemos
	definido.
	\subsection{\texttt{HighStockExtend}}
		El propósito de este Controlador es inicializar las dos extensiones de HighStock que discutimos previamente en este capitulo. Este controlador es
		invocado antes de empezar a construir los gráficos de la aplicación para que las extensiones este listas y sean aplicadas a estos.
	\subsection{\texttt{Navigation}}
		Este Controlador es el encargado de inicializar el \texttt{Ext.History}, mecanismo que solventa el problema de navegación por el
		historial en aplicaciones \emph{single page}. El problema y el mecanismo fueron descritos en secciones anteriores de este capitulo.
		\par
		El controlador  define la función \texttt{onLaunch}, función que es invocada una vez creada la Vista y el Modelo de la aplicación.
		Empieza invocando la función \texttt{Ext.History.init()}, función esencial para inicializar este módulo. Seguidamente define la
		función encargada de manejar el evento \texttt{change}, evento que se dispara al cambiar el \emph{hash} de la URL. Esta función
		soporta tres valores diferentes como \emph{hash} que son \texttt{[Spike, SpikeRevised, ChannelStats]}. Estos tres valores
		representan los tres módulos funcionales entre los que hacemos distinción.  Cambiando el \emph{hash} cambiamos el módulo funcional
		mostrado en pantalla.
		\par
		Podemos ver que el soporte de navegación por el historial es pobre en funcionalidad, por esta razón hemos propuesto como trabajo
		futuro extender y ampliar la funcionalidad de este.
		\par
		También debemos tener en cuenta que al inicializarse la aplicación puede haber un \emph{hash} especificado. Una vez especificado el
		comportamiento ante un evento \texttt{change} procedemos a evaluar el \emph{hash} actual. Este puede no estar presente, caso en el que
		cargamos el módulo funcional \texttt{Spike}. En el caso de la presencia de un \emph{hash} actuamos conforme a este.
	\subsection{\texttt{Spike}}
		Este controlador es directamente relacionado al módulo funcional con el mismo nombre, \texttt{Spike}. Este Controlador es algo más
		complicado que los anteriormente discutidos, este es compuesto por múltiples funciones. A continuación procedemos a explicar estas
		funciones.
		\subsubsection{\texttt{Launch()}}
			Inicializa el módulo funcional \texttt{Spike}. Es conveniente destacar que esta función no es \texttt{onLauch}, esta no es
			invocada automáticamente al inicio de la aplicación, somos nosotros los que la invocamos. Esta función inicializa el objeto
			\texttt{MyApp.app.spike}, objeto que debe contener todas las variables usadas en este módulo. La mayoría de las demás
			funciones aceptan el parámetro \texttt{module}, este parámetro debe ser el objeto mencionado anteriormente. Después de
			inicializar este objeto es invocada la función \texttt{loadInitialData()}.
		\subsubsection{\texttt{loadInitialData(module)}}
			Esta función carga los datos necesarios para construir el módulo. Los datos son cargados realizando una petición Ajax al
			\emph{back-end}. El servicio RPC que invocamos es \texttt{nmdbOriginalGroup}. Al cargar los datos con éxito son invocadas las
			funciones \texttt{initCandleChart()} y \texttt{initChannelChart()}. 
		\subsubsection{\texttt{initCandleChart(module)}}
			Esta función es la encargada de crear el gráfico \emph{Candlestick} con los datos de la estación. Hablaremos más a fondo sobre
			este gráfico en las secciones futuras donde discutiremos la herramienta desde un enfoque funcional.
		\subsubsection{\texttt{initChannelChart(module)}}
			Esta función es la encargada de crear el gráfico que representara los datos de los tubos contadores por separado. Igual que en
			el caso anterior hablaremos más sobre este gráfico en secciones futuras.
		\subsubsection{\texttt{LineOrOhcl(start, finish, N\_points)}}
			Anteriormente en este capitulo discutimos el problema que surge al intentar representar un gran número de datos en un gráfico
			convencional y que el gráfico \emph{Candlestick} daba solución a este problema. Esta función determina si debemos utilizar un
			gráfico de línea o bien uno \emph{Candlestick}. La cantidad de datos esta definida por los parámetros \texttt{start} y
			\texttt{finish}, el parámetro \texttt{N\_points} representa el número de pixeles que tenemos a disposición para representar
			los datos.
		\subsubsection{\texttt{updateMode(start, finish, module)}}
			Esta función es invocada cuando ocurre algún cambio en el gráfico \emph{Candlestick} y calcula el modo en que deben ser
			representados los datos. Esta función hace un uso intensivo de la función \texttt{LineOrOhcl}, pero tiene en cuenta más cosas
			como la serie actual.
		\subsubsection{\texttt{changeSeries(series, module)}}
			Esta función cambia la serie que es presentada en el gráfico \emph{Candlestick}. El parámetro \texttt{series} es un entero que
			puede tomar los siguientes valores \texttt{[1, 2, 3]}, donde estos representan uncorrected, corrected for pressure y
			corrected for efficiency.
		\subsubsection{\texttt{updateSeries(module)}}
			Esta función simplemente refresca los datos de las series del gráfico \emph{CandleStick}. Es invocada cada vez que ocurre
			algún cambio en este para refrescar los datos.
		\subsubsection{\texttt{updateCandleData(start, finish, module)}}
			Esta función carga los datos para el gráfico \emph{Candlestick} en función de la petición realizada por el usuario. Para
			cargar los datos la función realiza una petición Ajax al \emph{back-end}. La función invoca el servicio RPC
			\texttt{nmdbOriginalGroup} o \texttt{nmdbOriginalRaw} en función del valor devuelto por la función \texttt{LineOrOhcl()}. El
			intervalo de datos que será solicitado es definido por los parámetros \texttt{start} y \texttt{finish}. 
		\subsubsection{\texttt{updateChannelData(module)}}
			Esta función carga los datos para el gráfico que representara los datos de los tubos contadores por separado. Los datos son
			cargado del \emph{back-end} mediante una petición Ajax que invoca el servicio RPC \texttt{nmdadbRawData}.
		\subsubsection{\texttt{searchInterval(start, finish, module)}}
			Esta función nos permite hacer una búsqueda por intervalos temporales. El intervalo es definido por los parámetros
			\texttt{start} y \texttt{finish}.
		\subsubsection{\texttt{getTimestamp(str)}}
			Esta función acepta una cadena de texto que debe seguir un formato determinado y devuelve un objeto de la clase \texttt{Date}. 
		\subsubsection{\texttt{showCandle()}}
			Esta función muestra el gráfico \texttt{Candlestick} creado por este Controlador. Junto al gráfico también se asegura de
			mostrar los controles vinculados a este. Si es la primera vez que intentamos mostrar este gráfico el módulo entero no estará
			creado, esta función invoca la función \texttt{Launch()} en tal caso.
		\subsubsection{\texttt{showChannel()}}
			Esta función muestra el gráfico de los tubos contadores por separado. Junto al gráfico también se asegura de mostrar los
			controles vinculados a este

